"""
Strategy Engine - Executes Pine Script strategies
"""
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum
from datetime import datetime
import threading
import time
from loguru import logger

from algo_trader.core.order_manager import OrderManager, Order, OrderType, TransactionType, Exchange
from algo_trader.core.database import Database


class SignalType(Enum):
    BUY = "BUY"
    SELL = "SELL"
    EXIT_LONG = "EXIT_LONG"
    EXIT_SHORT = "EXIT_SHORT"
    NONE = "NONE"


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    signal_type: SignalType
    symbol: str
    price: float = None
    quantity: int = None
    stop_loss: float = None
    target: float = None
    timestamp: datetime = None
    strategy_name: str = None
    message: str = None


class StrategyEngine:
    """
    Executes trading strategies and manages signals
    """

    def __init__(self, order_manager: OrderManager, database: Database):
        self.order_manager = order_manager
        self.db = database
        self.active_strategies = {}  # name -> PineScriptStrategy instance
        self.signal_callbacks = []  # List of callbacks to call on new signal
        self._running = False
        self._thread = None

    def register_signal_callback(self, callback: Callable[[Signal], None]):
        """Register a callback to be called when signals are generated"""
        self.signal_callbacks.append(callback)

    def load_strategy(self, name: str, pine_script: str) -> bool:
        """
        Load and parse a Pine Script strategy
        """
        try:
            # Import here to avoid circular imports
            from algo_trader.strategies.pine_parser import PineScriptParser

            parser = PineScriptParser()
            strategy = parser.parse(pine_script)

            if strategy:
                self.active_strategies[name] = {
                    'parser': parser,
                    'strategy': strategy,
                    'pine_script': pine_script,
                    'enabled': False
                }
                # Save to database
                self.db.save_strategy(name, pine_script)
                logger.info(f"Strategy '{name}' loaded successfully")
                return True
            else:
                logger.error(f"Failed to parse strategy '{name}'")
                return False
        except Exception as e:
            logger.error(f"Error loading strategy '{name}': {e}")
            return False

    def enable_strategy(self, name: str) -> bool:
        """Enable a strategy for live trading"""
        if name not in self.active_strategies:
            logger.error(f"Strategy '{name}' not found")
            return False

        self.active_strategies[name]['enabled'] = True
        self.db.set_strategy_active(name, True)
        logger.info(f"Strategy '{name}' enabled")
        return True

    def disable_strategy(self, name: str) -> bool:
        """Disable a strategy"""
        if name not in self.active_strategies:
            return False

        self.active_strategies[name]['enabled'] = False
        self.db.set_strategy_active(name, False)
        logger.info(f"Strategy '{name}' disabled")
        return True

    def remove_strategy(self, name: str) -> bool:
        """Remove a strategy"""
        if name in self.active_strategies:
            del self.active_strategies[name]
            logger.info(f"Strategy '{name}' removed")
            return True
        return False

    def get_strategy_list(self) -> List[Dict]:
        """Get list of loaded strategies"""
        return [
            {
                'name': name,
                'enabled': data['enabled']
            }
            for name, data in self.active_strategies.items()
        ]

    def process_candle(self, symbol: str, candle: Dict) -> List[Signal]:
        """
        Process a new candle through all enabled strategies
        Returns list of signals generated
        """
        signals = []

        for name, data in self.active_strategies.items():
            if not data['enabled']:
                continue

            try:
                strategy = data['strategy']
                signal = strategy.process_candle(symbol, candle)

                if signal and signal.signal_type != SignalType.NONE:
                    signal.strategy_name = name
                    signal.timestamp = datetime.now()
                    signals.append(signal)

                    # Notify callbacks
                    for callback in self.signal_callbacks:
                        try:
                            callback(signal)
                        except Exception as e:
                            logger.error(f"Signal callback error: {e}")

            except Exception as e:
                logger.error(f"Error processing candle in strategy '{name}': {e}")

        return signals

    def execute_signal(self, signal: Signal, broker_name: str, quantity: int = None) -> Optional[Order]:
        """
        Execute a trading signal
        """
        if signal.signal_type == SignalType.NONE:
            return None

        # Determine transaction type
        if signal.signal_type in [SignalType.BUY]:
            transaction_type = TransactionType.BUY
        elif signal.signal_type in [SignalType.SELL, SignalType.EXIT_LONG]:
            transaction_type = TransactionType.SELL
        else:
            return None

        # Create order
        order = Order(
            symbol=signal.symbol,
            transaction_type=transaction_type,
            quantity=quantity or signal.quantity or 1,
            order_type=OrderType.MARKET,
            price=signal.price,
            exchange=Exchange.NSE
        )

        # Place order
        result = self.order_manager.place_order(order, broker_name)
        logger.info(f"Signal executed: {signal.signal_type.value} {signal.symbol} -> Order {result.order_id}")

        return result

    def start_live(self, data_feed, broker_name: str, symbols: List[str]):
        """
        Start live strategy execution
        data_feed should provide real-time candle data
        """
        self._running = True

        def run():
            logger.info("Strategy engine started in live mode")
            while self._running:
                for symbol in symbols:
                    try:
                        candle = data_feed.get_latest_candle(symbol)
                        if candle:
                            signals = self.process_candle(symbol, candle)
                            for signal in signals:
                                self.execute_signal(signal, broker_name)
                    except Exception as e:
                        logger.error(f"Live execution error for {symbol}: {e}")
                time.sleep(1)

        self._thread = threading.Thread(target=run, daemon=True)
        self._thread.start()

    def stop_live(self):
        """Stop live strategy execution"""
        self._running = False
        if self._thread:
            self._thread.join(timeout=5)
        logger.info("Strategy engine stopped")
